#include "types.h"
#include "versatilepb.h"

void main()
{
    u8 *p;
    u8 line[128];
    UART *up;
    VIC_INTENABLE |= UART0_IRQ_VIC_BIT;
    VIC_INTENABLE |= UART1_IRQ_VIC_BIT;

    VIC_INTENABLE |= TIMER01_IRQ_VIC_BIT; // timer0,1 at VIC.bit4
    VIC_INTENABLE |= TIMER23_IRQ_VIC_BIT; // timer2,3 at VIC.bit5

    uart_init();
    up = &uart[0];
    fbuf_init();
    p = &_binary___resource_images_image_bmp_start; // symbol generated by the linker based on the input file name
    u8 *pLine = NULL;
    //show_bmp(p, 0, 0);// show the image at the screen location (0,0)
    u8 c = ' ';

    timer_init();

    uprints(up, "[Debug Will Start]\n\r");
    //kprintf1("%c,%s,%d,%u,0x%x\n", 'A', "SM", -123, 321, 0xABCD);
    kprintf("%c,%s,%d,%u,0x%x\n", 'A', "SM", -123, 321, 0xABCD);
    kprintf("%c,%c,%c,%c,%c\n", 'A', 'B', 'C', 'D', 'E');
    kprintf("%c\n", 'A');
    kprintf("%s\n", "SM");
    kprintf("%d\n", -123);
    kprintf("%u\n", 321);
    kprintf("0x%x\n", 0xABCD);
    kprintf("0x%x\n", -0xCDEF);

    // for (u32 i = 0; i < 1; i++)
    // { // start all 4 timers
    //     timer_start(i);
    // }

    timer_start(2);
    timer_start(3);

    while (1)
    {
        ;
        // if(gDisplayContext.cursor_row == gDisplayContext.max_row)
        // {
        //     uprints(up, "[Input something through UART and then press Enter to show some chars:]\n\r");
        //     ugets(up, line);
        //     uprints(up, "[And you have entered below line from UART:]\n\r");
        //     uprints(up, line);
        //     pLine = &line[0];
        //     while(*pLine)
        //     {
        //         kputc(*pLine);
        //         pLine++;
        //     }

        // }
        // else
        // {
        //     kputc(c);
        //     c = (c+1>'~')?' ':c+1;
        // }
    }
}

void copy_vectors()
{
    extern u32 vectors_start, vectors_end;
    u32 *vectors_src = &vectors_start;
    u32 *vectors_dst = (u32 *)0;
    while (vectors_src < &vectors_end)
    {
        *vectors_dst++ = *vectors_src++;
    }
}

void IRQ_handler()
{
    u32 vicstatus = VIC_STATUS;

    //UART 0
    if (vicstatus & UART0_IRQ_VIC_BIT)
    {
        uart_handler(&uart[0]);
    }

    //UART 1
    if (vicstatus & UART1_IRQ_VIC_BIT)
    {
        uart_handler(&uart[1]);
    }

    // VIC status BITs: timer0,1=4, uart0=13, uart1=14
    if (vicstatus & TIMER01_IRQ_VIC_BIT)
    {// bit4=1:timer0,1, handle timer 0 and 1 one by one
        if (*(timer[0].base + TVALUE) == 0) // timer 0
            timer_handler(0);
        if (*(timer[1].base + TVALUE) == 0) // timer 1
            timer_handler(1);
    }
    if (vicstatus & TIMER23_IRQ_VIC_BIT)
    {// bit5=1:timer2,3, handle timer 2 and 3 one by one
        if (*(timer[2].base + TVALUE) == 0) // timer 2
            timer_handler(2);
        if (*(timer[3].base + TVALUE) == 0) // timer 3
            timer_handler(3);
    }
}

/*
If this one is used, comment out the "irq_handler:" in reset.S
*/
void __attribute__((interrupt)) irq_handler()
{
    IRQ_handler();
}
